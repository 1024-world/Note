<h1>数据结构-本段内容来源于《Redis设计与实现》</h1>

<h2>简单动态字符串</h2>
在Redis中里面，C字符串只会作为字符串字面量用在一些无需对字符串值进行修改的地方，比如打印日志。当需要的不仅仅是一个字符串字面量时，
Redis就会使用SDS来表示字符值，比如在Redis数据库里面，包含字符串值得键值对在底层都是SDS实现的。<br /><br />

每个sds.h/sdshdr结构表示一个SDS的值：<br />
```
struct sdshdr {
    int len; // 记录buf数组中已使用字节的数量，等于SDS所保存字符串的长度。
    int free; // 记录buff数组中未使用字节的数量。
    char buf[]; // 字节数组，用于保存字符串。
} listNode
```
SDS遵循C字符串以空字符串结尾的惯例，保存空字符的1字节空间不计算在SDS的len属性里面，并且为空字符串分配额外的1字节空间，
以及添加空字符到字符串末尾等操作，都是由SDS函数自动完成的。所以这个空字符对于SDS的使用者来说是完全透明的。遵循空字符结尾这一惯例的好处是，
SDS可以直接重用一部分C字符串函数库里面的函数。

<h3>SDS与C字符串的区别</h3>
1.常数复杂度获取字符串长度。<br />
C字符串本身并不记录自身的长度信息，所以为了获取一个C字符串的长度，程序必须遍历整个字符串，对遇到的每个字符串进行计数，直到遇到代表字符串结尾的空字符串为止，这个操作的复杂度为O(N)。<br />
SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O(1)。<br /><br />

设置和更新SDS的长度的工作由SDS的API在执行时自动完成的，使用SDS无须进行任何手动修改长度的工作。通过使用SDS而不是C字符串，
Redis将获取字符串长度所需的复杂度从O(N)降低到了O(1)，这确保了获取字符串长度的工作不会成为Redis的性能瓶颈。<br />

2.杜绝缓冲区溢出。<br />
C字符串不记录自身长度带来的另一个问题是容易造成缓冲区溢出。举个例子，目前内存中有两个紧邻着的C字符串s1和s2，现在需要对S1的内容进行修改，
但是却粗心的忘了为s1分配足够的内存空间，那么在s1的长度增加的情况下，s1的数据将溢出到s2所在的空间中，导致s2保存的内容被意外的修改。<br />
SDS的空间分配策略完全杜绝了发生缓冲区溢出的可能性：当SDS API需要对SDS进行修改时，API会先检查SDS的空间是否满足修改所需的要求，如果不满足的话，
API会自动将SDS的空间扩展至执行修改所需的大小，然后才执行实际的修改操作，所以使用SDS既不需要手动修改SDS的空间大小，也不会出现前面所说的缓冲区溢出。<br />

3.减少修改字符串时带来的内存重分配次数。<br />
一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组(额外的一个字符空间用来保存空字符)。
因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都要对保存这个C字符串的数组进行依次内存重分配操作。
在一般程序中，如果修改字符串长度的情况不太常出现，那么每次修改都需要执行一次内存重分配是可以接受的，但是Redis作为数据库，经常用于速度要求严苛，
数据被频繁修改的场合，这会对性能造成一定的影响，这也是采用SDS的原因。<br />

SDS实现了空间预分配和惰性空间释放两种优化策略。<br />
<h4>空间预分配</h4>
空间预分配用于优化SDS字符串的增长操作：当SDS的API对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必需的空间，还会为SDS分配额外未使用的空间。<br />
(1)修改后的SDS长度(也就是len属性的值)将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时len属性和free属性的值相等。<br />
(2)修改后的SDS长度大于1M，那么程序会分配1M的未使用空间。<br />
通过空间预分配策略，Redis可以减少连续执行字符串增长操作所需的内存重分配次数。将次数从必定N次降低到最多N次。<br />

<h4>惰性空间释放</h4>
惰性空间释放用于优化SDS字符串的缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。<br />
SDS提供了相应的API，让我们可以在有需要的时候，真正的释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。<br />

4.二进制安全。<br />
C字符串中的字符必须符合某种编码，并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，
这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频这样的二进制数据。<br />
虽然数据库一般用于保存文本数据，但是保存二进制数据的场景也不少见，因此为了确保Redis可以适用各种不同的使用场景，SDS的所有API都是二进制安全的，
所有API都会以处理二进制的方式来处理SDS存放在buf数组里的数据，程序不会对其中的数据做任何限制、过滤、或者假设，数据在写入时是什么样，它被读取时就是什么样。
SDS适用len属性的值而不是空字符来判断字符串是否结束。<br />

5.兼容部分C字符串函数。<br />

<h2>链表</h2>
链表提供了高效的节点重排能力，以及顺序性的节点访问方式，并且可以通过增删节点来灵活的调整链表的长度。<br />
链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量比较多的元素，又或者列表中包含的元素都是比较长的字符串时，
Redis就会使用链表作为列表键的底层实现。<br /><br />

每一个链表节点使用一个adlist.h/listNode结构来表示：
```
typedef struct listNode {
    struct listNode *prev; // 前置节点
    struct listNode *next; // 后置节点
    void *value; //节点的值
}
```
多个listNode可以通过prev和next指针组成双端链表。<br />
使用adlist.h/list来持有链表的话，操作会更方便。
```
typedef struct list {
    listNode *head; // 表头节点
    listNode *tail; // 表尾节点
    unsigned long len; // 链表所包含的节点数量
    void *(*dup) (void *ptr); // 节点值复制函数
    void *(*free) (void *ptr); // 节点值释放函数
    int (*match) (void *ptr, void *key); // 节点值对比函数
} list
```
list结构为链表提供了表头指针head、表尾指针tail，以及链表长度计算器len，而dup、free和match成员则是用于实现多态链表所需的类型特定函数。<br />

<h3>链表特性</h3>
1.双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的复杂度都是O(1)。<br />
2.无环：表头结点的prev指针和表尾节点的next指针都指向了NULL，对链表的访问以NULL为终点。<br />
3.表头指针和表尾指针：通过head指针和tail指针，获取表头节点和表尾节点的复杂度为O(1)。<br />
4.带链表长度计数器：使用list结构中的len属性对list持有的链表节点进行计数，程序获取链表中节点数量的复杂度为O(1)。<br />
5.多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数，所以链表可以用于保存各种不同类型的值。

<h2>字典</h2>
字典又称符号表、关联数组或映射，是一种保存键值对的抽象数据结构。<br />
字典在Redis中的应用非常广泛，Redis的数据库就是使用字典作为底层实现的对数据库的增删改查操作也是构建在对字典的操作之上。

<h3>字典的实现</h3>
1.哈希表：<br />
哈希表由dict.h/dictht结构定义：
```
typedef struct dictht {
    dictEntry **table; // 哈希表数组
    unsigned long size; // 哈希表大小
    unsigned long sizemask; // 哈希表大小掩码，用于计算索引值，总是等于size-1
    unsigned long used; // 该哈希表已有节点的数量
} dictht
```
table属性是一个数组，数组中的每一个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。<br />
size属性记录了哈希表的大小，也即是table数组的大小。<br />
used属性记录了哈希表目前已有节点的数量。<br />
sizemask属性的值总是等于size-1，这个属性与哈希值一起决定一个键应该被放到table数组的哪个索引上。

2.哈希表节点：<br />
哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对：
```
typedef struct dictEntry {
    void *key; // 键
    // 值
    union {
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    struct dictEntry *next;
} dictEntry;
```
key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。<br />
next属性指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一起，以此来解决键值对冲突的问题。<br />

3.字典：<br />
Redis的字典由dict.h/dict结构来表示：
```
typedef struct dict {
    dictType *type; // 类型特定函数
    void *privdata; // 私有数据
    dictht ht[2]; // 哈希表
    int trehashidx; // rehash索引，当rehash不再进行时，值为-1
} dict
```
type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：
type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。<br />
privdata属性则保存了需要传给那些类型特定函数的可选参数。
```
typedef struct dictType {
    unsigned int (*hashFunction) (const void *key); // 计算哈希值的函数
    void *(*keyDup)(void *privdata, const void *key); // 复制键的函数
    void *(*valDup)(void *privdata, const void *obj); // 复制值的函数
    int (*keyCompare) (void *privdata, const void *key1, const void *key2); // 对比键的函数
    void (*keyDestructor)(void *privdata, void *key) // 销毁键的函数
    void (*valDestructor)(void *privdata, void *obj); // 销毁值的函数
} dictType
```

ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht\[0]哈希表，ht\[1]哈希表只会在对ht\[0]哈希表进行rehash时使用。<br />
除了ht\[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的记录，如果目前没有在进行rehash，那么他的值为-1。<br />

<h3>哈希算法</h3>
当要将一个新的键值对添加到字典里面时，程序需要根据键值对的键计算出哈希值和索引值，然后在根据索引值，将包含新键值对的哈希表节点放到哈希数组的指定索引上面。<br />
Redis计算哈希值和索引值的方法：<br />
使用字典设置的哈希函数，计算键key的哈希值<br />
hash = dict->type->hashFunction(key);<br /><br />

使用哈希表的sizemask属性和哈希值，计算出索引值<br />
根据情况不同，ht\[x]可以是ht\[0]或者ht\[1]<br />
index = hash & dict->ht\[x].sizemask;<br />

Redis使用MurmurHash2算法来计算键的哈希值。<br /><br />

<h3>解决键冲突</h3>
当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突。<br />
Redis的哈希表使用链地址法来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表连接起来，这就解决了键冲突的问题。<br />
因为dictEntry节点组成的链表没有指向链表表尾的指针，所以为了速度考虑，程序总是将新节点添加到链表的表头位置(复杂度为O(1))，排在其他已有节点的前面。<br />

<h3>rehash</h3>
步骤：<br />
1.为字典的ht\[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht\[0]当前包含的键值对数量(也即是ht\[0].used属性的值)：<br />
如果执行的是扩展操作，那么ht\[1]的大小为第一个大于等于ht\[0].used*2的2的n次幂；<br />
如果执行得是收缩操作，那么ht\[1]的大小为第一个大于等于ht\[0].used的2的n次幂。<br />
2.将保存在ht\[0]中的所有键值对rehash到ht\[1]上面，rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht\[1]哈希表的指定位置上。<br />
3.当ht\[0]包含的所有键值对都迁移到ht\[1]之后(ht\[0]变为空表)，释放ht\[0]，将ht\[1]设置为ht\[0]，并在ht\[1]新创建一个空白哈希表，为下一次rehash做好准备。<br /><br />

触发条件：<br />



