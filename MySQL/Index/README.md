<h1>索引类型</h1>
<h2>B-Tree索引</h2>
1.InnoDB 使用B+Tree结构。<br /><br />
2.B-Tree结构意味着数据都是按照顺序存储的，并且每一个叶子页到根节点的距离相同。<br /><br />
3.B-Tree索引能够加快访问数据的速度。因为存储引擎不需要在进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。
根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层寻找。通过比较节点页的值和要查找的值可以找到合适的指针进入下一层子节点，
这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点比较特殊，
他们的指针指向的是被索引的数据，而不是其他的节点页。<br /><br />
4.B-Tree对索引列是顺序组织存储的，所以很适合查找范围数据。<br /><br />
5.索引对于多个值进行排序的依据是创建表语句定义索引时列的顺序。<br /><br />
6.索引有效性：<br />
全值匹配：和索引中的所有列进行匹配。<br/>
匹配最左前缀：联合索引中只使用索引的第一列。<br />
匹配列前缀：只匹配某一列的值的开头部分。<br />
匹配范围值：按照顺序查询某一个区间的数据<br />
只访问索引的查询：查询中只访问索引而不需要访问数据行。<br /><br />
7.索引无效性：<br />
非最左列查询：<br />
查询中有某个列的范围查询，则其右面所有列都无法使用索引优化查询。<br />
索引列的顺序很重要，优化时可以使用相同的列但是顺序不同的索引来满足不同类型的查询需求。<br />

<h2>哈希索引</h2>
1.哈希索引基于哈希表实现，只有精确匹配所有列的查询时才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，
哈希码是一个较小的值，并且不同键值行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，
同时在哈希表中保存指向每个数据行的指针。如果有多个列的哈希值相同，索引会以链表的形式存放多个记录的指针到同一个哈希条目中。<br /><br />
2.索引的本身只需要存储哈希值和行指针，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快。<br /><br />
3.索引的限制：<br />
(1)索引中只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以这一点对性能的影响并不明显。<br />
(2)哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。<br />
(3)哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。<br />
(4)哈希索引只支持等值比较查询，不支持范围查找。<br />
(5)哈希冲突很多的话，索引维护的代价会很高，包括删除、查找等操作。需要遍历对应哈希值的链表中的每一行，并找到对应行的引用。<br /><br />
4.创建自定义的哈希索引：<br />
思路很简单，在B-Tree的基础上创建一个伪哈希索引，这和真正的哈希索引不是一回事，因为还是使用B-Tree索引进行查找，
但是它使用哈希值而不是键本身进行索引查找。就是在数据行中增加一个字段存储索引的哈希值，然后再该列上面建立一个索引，
查询时使用该索引进行查询，适用于在较大的字符串上面建立索引。使用触发器维护哈希值，这样增加了额外的维护工作。<br />

<h1>索引策略</h1>
<h2>索引列顺序</h2>
1.将选择性最高的列放在前面通常是最好的，但通常不如避免随机I/O和排序那么重要，当不需要考虑排序和分组时，这样做是很好的，
这时候索引的作用只是用于优化WHERE条件的查找。然而，性能不只是依赖于所有索引列的选择性，也和查询条件的具体值有关，即值的分布，
需要根据那些运行频率最高的查询来确定索引列的顺序，让这种情况下索引的选择性最高。<br /><br />
2.对于系统中存在的管理员、guset等用户，往往存在者更多的数据，针对这类用户的数据，需要视具体情况而定。<br /><br />
3.最左匹配原则<br /><br />

<h2>索引和锁</h2>
1.索引可以让查询锁定更少的行。如果你的查询从不访问那些不需要的行，那么就会锁定更少的行，从这两个方面来看这对性能都有好处。<br /><br />
2.InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。
但这只有当InnoDB在存储引擎层能够过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层以后，
MySQL服务器才能应用WHERE子句。这是已经无法避免锁定行了：InnoDB已经锁住了这些行，到适当的时候才释放。<br /><br />
3.InnoDB在二级索引上面使用共享(读)锁，但访问主键索引需要排他(写)锁。<br /><br />

<h2>联合索引</h2>
1.在多个列上面建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。<br /><br />
2.联合的策略：<br />
(1)当出现服务器对多个索引做相交操作时(通常有多个AND条件)，通常意味着需要一个包含所有相关列的多列索引，而不是多个独立的单独索引。<br />
(2)当服务器需要对多个索引做联合操作时(通常有多个OR条件)，通常需要耗费大量的CPU和内存资源在算法的缓存、排序和合并操作上。
特别是当其中有些索引的选择性不高，需要合并扫描返回大量的数据的时候。<br />

<h2>聚簇索引</h2>
1.聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。具体的细节依赖于其实现方式，但是InnoDB的聚簇索引实际上是在同一结构中保存了B-Tree索引和数据行。<br /><br />
2.当表有聚簇索引时，他的数据行实际上存放在索引的叶子页中。术语聚簇表示数据行和相邻的键值紧凑的存储在一起。因为无法同时将数据行存放在两个不同的地方，
所以一个表只能有一个聚簇索引。<br /><br />
3.InnoDB会选择一个唯一的非空索引代替。如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引，
InnoDB会隐式定义一个主键来作为聚簇索引。InnoDB只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。
<h3>聚簇索引的优点：</h3>
1.可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。
如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O。<br />
2.数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。<br />
3.使用覆盖索引扫描的查询可以直接使用叶节点的主键值。<br />
4.MyISAM索引的叶子节点存储的是行指针，而InnoDB存储的是整个数据行，对于二级索引，InnoDB的叶子节点存储的是主键值，
而不是行指针，这样实现的好处是减少了当出现行移动或者数据页分裂时二级索引的维护工作。
<h3>聚簇索引的缺点：</h3>
1。聚簇索引最大限度的提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。<br />
2.插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，
那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。<br />
3.更新聚簇索引列的代价很大，因为会强制InnoDB将每个被更新的行移动到新的位置。<br />
4.基于聚簇索引的表插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”问题。当行的主键值要求必须要将这一行数据插入到某个已满的页中时，
存储引擎会将该页分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂可能导致表占用更多的磁盘空间。<br />
5.聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据库存储不连续的时候。<br />
6.二级索引可能比想象的要更大，因为二级索引的叶子节点包含了引用行的主键列。<br />
7.二级索引访问需要两次索引查找，而不是一次。
<h3>按照主键顺序插入行优点：</h3>
因为主键的值是顺序的，所以InnoDB会把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子(InnoDB默认的最大填充因子时页大小的15/16，
留出部分用于以后修改)时，下一条记录就会被写入到新的页中，一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满，这也正是所期望的结果。
<h3>按照主键顺序插入行缺点：</h3>
1.写入的目标页可能已经刷到磁盘上并从缓存中移除，或者还没有被加载到缓存中。InnoDB在插入之前不得不先找到并从磁盘读取目标页到内存中，这将导致大量的随机I/O。<br />
2.因为写入时乱序的，InnoDB不得不频繁的做页分裂操作，以便为新的行分配空间，页分裂导致移动大量数据，一次插入最少需要修改三个页面而不是一个页。<br />
3.由于频繁的页分裂，页会变得稀疏并被不规则的填充，所以最终数据会有碎片。

<h2>覆盖索引</h2>
1.一个索引包含所有需要查询字段的值，我们称之为“覆盖索引”。<br /><br />
2.覆盖索引是非常有用的工具，能够极大的提高性能。考虑一下如果查询只需要扫描索引而无需回表，会带来多少好处。<br />
优点：<br />
(1)索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大的减少数据访问量。这对缓存的负载非常重要，<br />
因为这种情况下响应时间大部分花费在数据拷贝上面。覆盖索引对于I/O密集型的应用也有帮助，因为索引比数据更小，更容易全部放在内存中。
(2)因为索引是按照列值顺序存储的，所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要小的多。<br />
(3)一些存储引擎如MyISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用。
这可能导致一次严重的性能问题，尤其是那些系统调用占了数据访问中的最大开销的场景。<br />
(4)由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。<br /><br />
3.MySQL只能使用B-Tree索引做覆盖索引。因为B-Tree索引中存储了数据。

<h2>前缀索引</h2>
1.有时候需要索引很长的字符列，这会让索引变得大且慢，一个策略是模拟哈希索引，但有时候还不够，这是我们需要创建其他类型的索引。
通常我们可以索引开始的部分字符，这样可以大大的节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。<br /><br />
2.索引的选择性：不重复的索引值和数据表的记录总数的比值。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。
，唯一索引的选择性最好，为1，性能也是最好的。<br /><br />
3.诀窍在于要选择足够长的前缀以保证较高的选择性，同时又不能太长(以便节约空间)。<br /><br />
4.前缀索引是一种能使索引更小、更快的有效办法，但是另一方面也有其缺点，MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。
<h4>为什么建立前缀索引？</h4>
当一个较大的字符串作为索引时，会导致主键索引变得很大，同时其他二级索引也会变得很大，这样会降低索引的性能。同时MySQL聚簇索引存储数据，
而每个页最多存储16KB，过多的数据占用更多的页空间，查询数据时会有更多的I/O产生。

<h2>冗余/重复索引</h2>
1.重复索引：在相同的数据列上面按照相同的顺序建立相同的索引。MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也要逐个的进行考虑，
这会影响性能。返现这样的索引应该立即删除。<br /><br />
2.冗余索引：例如创建了(A,B)索引，但是又创建了A索引，这就是冗余索引。冗余索引通常发生在为表添加新的索引时。<br /><br />
3.大多数情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新的索引。但也有的时候出于性能方面的考虑需要冗余索引，
因为扩展已有的索引会导致其变得太大，从而影响其他其他使用该索引的查询的性能。

<h2>使用索引扫描做排序</h2>
1.MySQL有两种方式可以生成有序的结果：一种是通过排序操作，一种是按索引顺序进行扫描。<br /><br />
2.如果EXPLAIN出来的type列的值为Index，则说明MySQL使用了索引扫描来做排序。<br /><br />
3.扫描索引本身是很快的，因为只需要从一条记录移动到紧接着的下一条记录，如果索引不能覆盖查询所需要的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。
这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。<br /><br />
4.MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样做是最好的。<br /><br />
5.只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向(倒序或者正序)都一样时，MySQL才能使用索引来对结果做排序。
如果查询需要关联多张表时，则只有当ORDER BY自居引用的字段全部为第一个字段时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：
需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用自身的索引排序。<br /><br />
6.有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果where子句或者JOIN子句中对这些列指定了常量，就可以弥补“索引”的不足。








