MySQL有两种方式可以生成有序的结果：一种是通过排序操作，一种是按索引顺序进行扫描。

如果EXPLAIN出来的type列的值为Index，则说明MySQL使用了索引扫描来做排序。

扫描索引本身是很快的，因为只需要从一条记录移动到紧接着的下一条记录，如果索引不能覆盖查询所需要的全部列，那就不得不每扫描一条索引记录就都回表查询一次对应的行。这基本上都是随机I/O，因此按索引顺序读取数据的速度通常要比顺序地全表扫描慢，尤其是在I/O密集型的工作负载时。

MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样做是最好的。

只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向(倒序或者正序)都一样时，MySQL才能使用索引来对结果做排序。如果查询需要关联多张表时，则只有当ORDER BY自居引用的字段全部为第一个字段时，才能使用索引做排序。ORDER BY子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用自身的索引排序。

有一种情况下ORDER BY子句可以不满足索引的最左前缀的要求，就是前导列为常量的时候。如果where子句或者JOIN子句中对这些列指定了常量，就可以弥补“索引”的不足。