<h1>锁</h1>
读锁(共享锁)：锁之间相互不阻塞。多个客户可以在同一时间读取同一个资源，而互不干扰。<br /><br />
写锁(排他锁)：阻塞其他的写锁和读锁。<br /><br />
锁粒度：提高并发性的方式就是让锁定的对象更具选择性，尽量只锁定需要修改的部分数据，而不是所有的资源。<br /><br />
表锁(table lock)：表锁是MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。一个用户在对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。<br /><br />
行锁(row lock)：行级锁可以最大程度的支持并发处理(同时带来最大的锁开销)，行级锁只在存储引擎层实现，而不是MySQL服务器层。<br /><br />
加锁也需要消耗系统资源，锁的各种操作，包括获得锁、检查锁是否已经解除、释放锁等，都会增加系统的开销。如果系统花费大量的时间来管理锁，而不是存取数据，那么系统的性能可能会因此受到影响。<br /><br />
锁策略就是在锁的开销和数据的安全性之间寻求平衡。<br /><br />

<h1>MVCC</h1>
多版本并发控制，可以看作是行级锁的一个变种。他在很多情况下避免了加锁操作，因此开销更低。<br /><br />
MVCC的实现，是通过保存数据在某个时间点的快照来实现的。不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。<br /><br />
InnoDB的MVCC，通过在每行记录的后面保存两个隐藏的列来实现。这两个列，一个保存了行的创建时间，一个保存行的过期时间，
存储的并不是真实的时间值，而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，
用来和查询到的每行记录到的版本号进行比较。<br /><br />
MVCC只在读已提交和可重复读两个事务隔离级别下面进行工作，其他事务隔离级别都和MVCC不兼容。